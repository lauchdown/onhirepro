import frappe
import pandas as pd
import numpy as np
import json
import os
import matplotlib.pyplot as plt
from datetime import datetime, timedelta
from prophet import Prophet
from prophet.diagnostics import cross_validation, performance_metrics
from prophet.plot import plot_cross_validation_metric
from sklearn.metrics import mean_absolute_error, mean_squared_error
from frappe.utils import nowdate, add_days, getdate, add_months, get_datetime
from onhire_pro.reports.forecasting.data_collector import KPIDataCollector

class ForecastingEngine:
    """
    Engine for generating forecasts for KPIs based on historical data.
    
    This class provides methods to train forecasting models, generate predictions,
    evaluate model performance, and store forecasted values in the database.
    """
    
    def __init__(self, company=None):
        """
        Initialize the forecasting engine.
        
        Args:
            company (str, optional): Company to generate forecasts for. If not specified,
                                    uses the default company from user preferences.
        """
        self.company = company or frappe.defaults.get_user_default("company")
        self.data_collector = KPIDataCollector(self.company)
        
        # Default forecasting parameters
        self.default_params = {
            "item_utilization_rate": {
                "seasonality_mode": "multiplicative",
                "changepoint_prior_scale": 0.05,
                "seasonality_prior_scale": 10.0,
                "weekly_seasonality": True,
                "daily_seasonality": False,
                "yearly_seasonality": True
            },
            "total_rental_revenue": {
                "seasonality_mode": "multiplicative",
                "changepoint_prior_scale": 0.05,
                "seasonality_prior_scale": 10.0,
                "weekly_seasonality": True,
                "daily_seasonality": False,
                "yearly_seasonality": True
            },
            "booking_conversion_rate": {
                "seasonality_mode": "multiplicative",
                "changepoint_prior_scale": 0.05,
                "seasonality_prior_scale": 10.0,
                "weekly_seasonality": True,
                "daily_seasonality": False,
                "yearly_seasonality": True
            },
            "average_rental_duration": {
                "seasonality_mode": "additive",
                "changepoint_prior_scale": 0.05,
                "seasonality_prior_scale": 10.0,
                "weekly_seasonality": True,
                "daily_seasonality": False,
                "yearly_seasonality": True
            },
            "maintenance_turnaround_time": {
                "seasonality_mode": "additive",
                "changepoint_prior_scale": 0.05,
                "seasonality_prior_scale": 10.0,
                "weekly_seasonality": True,
                "daily_seasonality": False,
                "yearly_seasonality": True
            }
        }
        
        # Default forecasting horizons (in days)
        self.default_horizons = {
            "item_utilization_rate": [30, 60, 90],
            "total_rental_revenue": [30, 60, 90],
            "booking_conversion_rate": [30, 60],
            "average_rental_duration": [30, 60],
            "maintenance_turnaround_time": [30]
        }
    
    def create_forecasted_kpi_value_doctype(self):
        """
        Create the Forecasted KPI Value DocType if it doesn't exist.
        
        This function creates a new DocType to store forecasted KPI values
        generated by the forecasting engine.
        
        Returns:
            bool: True if successful, False otherwise
        """
        try:
            # Check if DocType already exists
            if frappe.db.exists("DocType", "Forecasted KPI Value"):
                return True
            
            # Create new DocType
            doctype = frappe.new_doc("DocType")
            doctype.name = "Forecasted KPI Value"
            doctype.module = "OnHire Pro"
            doctype.custom = 1
            doctype.autoname = "format:FKV-{kpi_name}-{target_date}-{company}"
            doctype.description = "Forecasted values of KPIs"
            doctype.is_submittable = 0
            doctype.is_tree = 0
            doctype.is_calendar_and_gantt = 0
            
            # Add fields
            doctype.fields = [
                {
                    "fieldname": "kpi_name",
                    "fieldtype": "Data",
                    "label": "KPI Name",
                    "reqd": 1,
                    "in_list_view": 1,
                    "in_standard_filter": 1
                },
                {
                    "fieldname": "forecast_date",
                    "fieldtype": "Date",
                    "label": "Forecast Date",
                    "reqd": 1,
                    "in_list_view": 1,
                    "in_standard_filter": 1
                },
                {
                    "fieldname": "target_date",
                    "fieldtype": "Date",
                    "label": "Target Date",
                    "reqd": 1,
                    "in_list_view": 1,
                    "in_standard_filter": 1
                },
                {
                    "fieldname": "forecasted_value",
                    "fieldtype": "Float",
                    "label": "Forecasted Value",
                    "reqd": 1,
                    "in_list_view": 1
                },
                {
                    "fieldname": "lower_bound",
                    "fieldtype": "Float",
                    "label": "Lower Bound",
                    "reqd": 1
                },
                {
                    "fieldname": "upper_bound",
                    "fieldtype": "Float",
                    "label": "Upper Bound",
                    "reqd": 1
                },
                {
                    "fieldname": "algorithm",
                    "fieldtype": "Select",
                    "label": "Algorithm",
                    "options": "Prophet\nARIMA\nExponential Smoothing",
                    "default": "Prophet",
                    "reqd": 1
                },
                {
                    "fieldname": "accuracy",
                    "fieldtype": "Float",
                    "label": "Accuracy",
                    "description": "Forecast accuracy (MAPE)"
                },
                {
                    "fieldname": "historical_data_points",
                    "fieldtype": "Int",
                    "label": "Historical Data Points",
                    "description": "Number of historical data points used for forecasting"
                },
                {
                    "fieldname": "company",
                    "fieldtype": "Link",
                    "label": "Company",
                    "options": "Company",
                    "reqd": 1,
                    "in_standard_filter": 1
                }
            ]
            
            # Add permissions
            doctype.permissions = [
                {
                    "role": "System Manager",
                    "read": 1,
                    "write": 1,
                    "create": 1,
                    "delete": 1,
                    "report": 1,
                    "export": 1
                },
                {
                    "role": "Analytics Manager",
                    "read": 1,
                    "write": 1,
                    "create": 1,
                    "delete": 0,
                    "report": 1,
                    "export": 1
                }
            ]
            
            # Save DocType
            doctype.insert()
            
            # Create indexes for better performance
            frappe.db.sql("""
                CREATE INDEX IF NOT EXISTS idx_forecasted_kpi_value_kpi_target
                ON `tabForecasted KPI Value` (kpi_name, target_date)
            """)
            
            frappe.db.sql("""
                CREATE INDEX IF NOT EXISTS idx_forecasted_kpi_value_forecast_date
                ON `tabForecasted KPI Value` (forecast_date)
            """)
            
            frappe.db.sql("""
                CREATE INDEX IF NOT EXISTS idx_forecasted_kpi_value_company
                ON `tabForecasted KPI Value` (company)
            """)
            
            return True
        except Exception as e:
            frappe.log_error(
                f"Error creating Forecasted KPI Value DocType: {str(e)}\n{frappe.get_traceback()}",
                "DocType Creation Error"
            )
            return False
    
    def prepare_data_for_prophet(self, df):
        """
        Prepare data for Prophet forecasting model.
        
        Args:
            df (pandas.DataFrame): DataFrame with dates and values
            
        Returns:
            pandas.DataFrame: DataFrame formatted for Prophet
        """
        # Prophet requires columns named 'ds' and 'y'
        prophet_df = df.rename(columns={"date": "ds", "value": "y"})
        
        # Handle missing values
        prophet_df = prophet_df.dropna()
        
        return prophet_df
    
    def train_prophet_model(self, df, params=None):
        """
        Train a Prophet forecasting model.
        
        Args:
            df (pandas.DataFrame): DataFrame with dates and values
            params (dict, optional): Parameters for the Prophet model
            
        Returns:
            prophet.Prophet: Trained Prophet model
        """
        # Prepare data
        prophet_df = self.prepare_data_for_prophet(df)
        
        if prophet_df.empty:
            frappe.log_error(
                "No valid data available for training Prophet model",
                "Forecasting Error"
            )
            return None
        
        # Create and train model
        model = Prophet(**params) if params else Prophet()
        
        try:
            model.fit(prophet_df)
            return model
        except Exception as e:
            frappe.log_error(
                f"Error training Prophet model: {str(e)}\n{frappe.get_traceback()}",
                "Forecasting Error"
            )
            return None
    
    def generate_forecast(self, model, periods=30):
        """
        Generate forecast using a trained model.
        
        Args:
            model (prophet.Prophet): Trained Prophet model
            periods (int, optional): Number of periods to forecast
            
        Returns:
            pandas.DataFrame: DataFrame with forecasted values
        """
        if model is None:
            return None
        
        try:
            # Create future dataframe
            future = model.make_future_dataframe(periods=periods)
            
            # Generate forecast
            forecast = model.predict(future)
            
            return forecast
        except Exception as e:
            frappe.log_error(
                f"Error generating forecast: {str(e)}\n{frappe.get_traceback()}",
                "Forecasting Error"
            )
            return None
    
    def evaluate_model(self, model, df, periods=30):
        """
        Evaluate a forecasting model using cross-validation.
        
        Args:
            model (prophet.Prophet): Trained Prophet model
            df (pandas.DataFrame): DataFrame with historical data
            periods (int, optional): Number of periods to forecast
            
        Returns:
            dict: Evaluation metrics
        """
        if model is None or df.empty:
            return None
        
        try:
            # Prepare data
            prophet_df = self.prepare_data_for_prophet(df)
            
            # Perform cross-validation
            cv_results = cross_validation(
                model,
                initial='90 days',
                period='30 days',
                horizon=f'{periods} days'
            )
            
            # Calculate performance metrics
            metrics = performance_metrics(cv_results)
            
            # Calculate MAPE
            mape = metrics['mape'].mean()
            
            # Calculate RMSE
            rmse = metrics['rmse'].mean()
            
            return {
                "mape": mape,
                "rmse": rmse,
                "cv_results": cv_results,
                "metrics": metrics
            }
        except Exception as e:
            frappe.log_error(
                f"Error evaluating model: {str(e)}\n{frappe.get_traceback()}",
                "Forecasting Error"
            )
            return None
    
    def plot_forecast(self, model, forecast, df, file_path):
        """
        Plot forecast and historical data.
        
        Args:
            model (prophet.Prophet): Trained Prophet model
            forecast (pandas.DataFrame): DataFrame with forecasted values
            df (pandas.DataFrame): DataFrame with historical data
            file_path (str): Path to save the plot
            
        Returns:
            bool: True if successful, False otherwise
        """
        if model is None or forecast is None or df.empty:
            return False
        
        try:
            # Create figure
            fig = plt.figure(figsize=(12, 6))
            
            # Plot forecast
            ax = fig.add_subplot(111)
            
            # Plot historical data
            prophet_df = self.prepare_data_for_prophet(df)
            ax.scatter(prophet_df['ds'], prophet_df['y'], color='black', label='Historical')
            
            # Plot forecast
            ax.plot(forecast['ds'], forecast['yhat'], color='blue', label='Forecast')
            
            # Plot uncertainty intervals
            ax.fill_between(
                forecast['ds'],
                forecast['yhat_lower'],
                forecast['yhat_upper'],
                color='blue',
                alpha=0.2,
                label='Uncertainty'
            )
            
            # Add labels and title
            ax.set_xlabel('Date')
            ax.set_ylabel('Value')
            ax.set_title('Forecast with Prophet')
            ax.legend()
            
            # Save figure
            plt.savefig(file_path)
            plt.close(fig)
            
            return True
        except Exception as e:
            frappe.log_error(
                f"Error plotting forecast: {str(e)}\n{frappe.get_traceback()}",
                "Forecasting Error"
            )
            return False
    
    def store_forecast(self, kpi_name, forecast, forecast_date=None, algorithm="Prophet", accuracy=None, historical_data_points=None):
        """
        Store forecasted values in the database.
        
        Args:
            kpi_name (str): Name of the KPI
            forecast (pandas.DataFrame): DataFrame with forecasted values
            forecast_date (str, optional): Date when the forecast was generated
            algorithm (str, optional): Algorithm used for forecasting
            accuracy (float, optional): Forecast accuracy (MAPE)
            historical_data_points (int, optional): Number of historical data points used
            
        Returns:
            int: Number of forecasted values stored
        """
        if forecast is None:
            return 0
        
        # Ensure the DocType exists
        self.create_forecasted_kpi_value_doctype()
        
        # Set default forecast date to today
        if forecast_date is None:
            forecast_date = nowdate()
        
        # Extract future dates (after forecast_date)
        future_forecast = forecast[forecast['ds'] > pd.to_datetime(forecast_date)]
        
        count = 0
        for _, row in future_forecast.iterrows():
            try:
                # Check if a record already exists for this KPI, target date, and company
                target_date = row['ds'].strftime("%Y-%m-%d")
                existing = frappe.db.exists(
                    "Forecasted KPI Value",
                    {
                        "kpi_name": kpi_name,
                        "target_date": target_date,
                        "company": self.company,
                        "forecast_date": forecast_date
                    }
                )
                
                if existing:
                    # Update existing record
                    doc = frappe.get_doc("Forecasted KPI Value", existing)
                    doc.forecasted_value = row['yhat']
                    doc.lower_bound = row['yhat_lower']
                    doc.upper_bound = row['yhat_upper']
                    doc.algorithm = algorithm
                    if accuracy is not None:
                        doc.accuracy = accuracy
                    if historical_data_points is not None:
                        doc.historical_data_points = historical_data_points
                    doc.save()
                else:
                    # Create new record
                    doc = frappe.new_doc("Forecasted KPI Value")
                    doc.kpi_name = kpi_name
                    doc.forecast_date = forecast_date
                    doc.target_date = target_date
                    doc.forecasted_value = row['yhat']
                    doc.lower_bound = row['yhat_lower']
                    doc.upper_bound = row['yhat_upper']
                    doc.algorithm = algorithm
                    doc.company = self.company
                    if accuracy is not None:
                        doc.accuracy = accuracy
                    if historical_data_points is not None:
                        doc.historical_data_points = historical_data_points
                    doc.insert()
                
                count += 1
            except Exception as e:
                frappe.log_error(
                    f"Error storing forecast for KPI {kpi_name} on {target_date}: {str(e)}\n{frappe.get_traceback()}",
                    "Forecast Storage Error"
                )
        
        return count
    
    def forecast_kpi(self, kpi_name, historical_days=365, forecast_periods=None, params=None):
        """
        Generate forecast for a specific KPI.
        
        Args:
            kpi_name (str): Name of the KPI to forecast
            historical_days (int, optional): Number of historical days to use
            forecast_periods (list, optional): List of periods to forecast
            params (dict, optional): Parameters for the Prophet model
            
        Returns:
            dict: Forecasting results
        """
        try:
            # Set default forecast periods if not specified
            if forecast_periods is None:
                forecast_periods = self.default_horizons.get(kpi_name, [30])
            
            # Set default parameters if not specified
            if params is None:
                params = self.default_params.get(kpi_name, {})
            
            # Calculate date range for historical data
            end_date = add_days(nowdate(), -1)  # Yesterday
            start_date = add_days(end_date, -historical_days)  # X days before yesterday
            
            # Get historical data
            df = self.data_collector.get_historical_kpi_data(kpi_name, start_date, end_date)
            
            # Fill missing dates
            df = self.data_collector.fill_missing_dates(df, start_date, end_date)
            
            # Check if we have enough data
            if len(df) < 30:
                frappe.log_error(
                    f"Insufficient historical data for KPI {kpi_name}. Need at least 30 data points, got {len(df)}.",
                    "Forecasting Error"
                )
                return {
                    "success": False,
                    "error": "Insufficient historical data",
                    "kpi_name": kpi_name
                }
            
            # Train model
            model = self.train_prophet_model(df, params)
            
            if model is None:
                return {
                    "success": False,
                    "error": "Failed to train model",
                    "kpi_name": kpi_name
                }
            
            # Generate forecasts for each period
            results = {}
            for period in forecast_periods:
                # Generate forecast
                forecast = self.generate_forecast(model, periods=period)
                
                if forecast is None:
                    results[period] = {
                        "success": False,
                        "error": "Failed to generate forecast"
                    }
                    continue
                
                # Evaluate model
                evaluation = self.evaluate_model(model, df, periods=period)
                
                # Store forecast
                count = self.store_forecast(
                    kpi_name,
                    forecast,
                    algorithm="Prophet",
                    accuracy=evaluation["mape"] if evaluation else None,
                    historical_data_points=len(df)
                )
                
                # Plot forecast
                plot_dir = os.path.join(frappe.get_site_path(), "public", "files", "forecasts")
                os.makedirs(plot_dir, exist_ok=True)
                plot_file = os.path.join(plot_dir, f"{kpi_name}_{period}days_{nowdate()}.png")
                plot_success = self.plot_forecast(model, forecast, df, plot_file)
                
                results[period] = {
                    "success": True,
                    "forecast": forecast,
                    "evaluation": evaluation,
                    "stored_count": count,
                    "plot_file": plot_file if plot_success else None
                }
            
            return {
                "success": True,
                "kpi_name": kpi_name,
                "historical_data_points": len(df),
                "results": results
            }
        except Exception as e:
            frappe.log_error(
                f"Error forecasting KPI {kpi_name}: {str(e)}\n{frappe.get_traceback()}",
                "Forecasting Error"
            )
            return {
                "success": False,
                "error": str(e),
                "kpi_name": kpi_name
            }
    
    def forecast_all_kpis(self, historical_days=365):
        """
        Generate forecasts for all forecastable KPIs.
        
        Args:
            historical_days (int, optional): Number of historical days to use
            
        Returns:
            dict: Forecasting results for all KPIs
        """
        results = {}
        
        for kpi_name in self.data_collector.forecastable_kpis:
            results[kpi_name] = self.forecast_kpi(kpi_name, historical_days)
        
        return results
    
    def get_forecasted_values(self, kpi_name, start_date=None, end_date=None, latest_forecast_only=True):
        """
        Retrieve forecasted values for a KPI.
        
        Args:
            kpi_name (str): Name of the KPI
            start_date (str, optional): Start date for the forecast period
            end_date (str, optional): End date for the forecast period
            latest_forecast_only (bool, optional): Whether to return only the latest forecast
            
        Returns:
            pandas.DataFrame: DataFrame with forecasted values
        """
        try:
            # Set default date range if not specified
            if start_date is None:
                start_date = nowdate()
            if end_date is None:
                end_date = add_days(nowdate(), 90)
            
            # Build filters
            filters = {
                "kpi_name": kpi_name,
                "target_date": ["between", [start_date, end_date]],
                "company": self.company
            }
            
            # If we only want the latest forecast, get the latest forecast date first
            if latest_forecast_only:
                latest_forecast = frappe.db.get_all(
                    "Forecasted KPI Value",
                    filters={
                        "kpi_name": kpi_name,
                        "company": self.company
                    },
                    fields=["MAX(forecast_date) as latest_date"],
                    as_list=True
                )
                
                if latest_forecast and latest_forecast[0][0]:
                    filters["forecast_date"] = latest_forecast[0][0]
            
            # Query the database for forecasted values
            data = frappe.db.get_all(
                "Forecasted KPI Value",
                filters=filters,
                fields=[
                    "target_date",
                    "forecasted_value",
                    "lower_bound",
                    "upper_bound",
                    "forecast_date",
                    "algorithm",
                    "accuracy"
                ],
                order_by="target_date"
            )
            
            if not data:
                return pd.DataFrame(columns=[
                    "target_date",
                    "forecasted_value",
                    "lower_bound",
                    "upper_bound",
                    "forecast_date",
                    "algorithm",
                    "accuracy"
                ])
            
            # Convert to DataFrame
            df = pd.DataFrame(data)
            df["target_date"] = pd.to_datetime(df["target_date"])
            df["forecast_date"] = pd.to_datetime(df["forecast_date"])
            
            return df
        except Exception as e:
            frappe.log_error(
                f"Error retrieving forecasted values for KPI {kpi_name}: {str(e)}\n{frappe.get_traceback()}",
                "Forecast Retrieval Error"
            )
            return pd.DataFrame(columns=[
                "target_date",
                "forecasted_value",
                "lower_bound",
                "upper_bound",
                "forecast_date",
                "algorithm",
                "accuracy"
            ])
    
    def compare_forecast_with_actual(self, kpi_name, forecast_date, start_date=None, end_date=None):
        """
        Compare forecasted values with actual values.
        
        Args:
            kpi_name (str): Name of the KPI
            forecast_date (str): Date when the forecast was generated
            start_date (str, optional): Start date for comparison
            end_date (str, optional): End date for comparison
            
        Returns:
            dict: Comparison results
        """
        try:
            # Set default date range if not specified
            if start_date is None:
                start_date = add_days(forecast_date, 1)
            if end_date is None:
                end_date = min(add_days(forecast_date, 30), nowdate())
            
            # Get forecasted values
            forecast_filters = {
                "kpi_name": kpi_name,
                "forecast_date": forecast_date,
                "target_date": ["between", [start_date, end_date]],
                "company": self.company
            }
            
            forecast_data = frappe.db.get_all(
                "Forecasted KPI Value",
                filters=forecast_filters,
                fields=[
                    "target_date",
                    "forecasted_value",
                    "lower_bound",
                    "upper_bound"
                ],
                order_by="target_date"
            )
            
            if not forecast_data:
                return {
                    "success": False,
                    "error": "No forecast data available",
                    "kpi_name": kpi_name
                }
            
            # Convert to DataFrame
            forecast_df = pd.DataFrame(forecast_data)
            forecast_df["target_date"] = pd.to_datetime(forecast_df["target_date"])
            
            # Get actual values
            actual_df = self.data_collector.get_historical_kpi_data(kpi_name, start_date, end_date)
            
            if actual_df.empty:
                return {
                    "success": False,
                    "error": "No actual data available",
                    "kpi_name": kpi_name
                }
            
            # Merge forecast and actual data
            comparison_df = pd.merge(
                forecast_df,
                actual_df,
                left_on="target_date",
                right_on="date",
                how="inner"
            )
            
            if comparison_df.empty:
                return {
                    "success": False,
                    "error": "No overlapping data for comparison",
                    "kpi_name": kpi_name
                }
            
            # Calculate metrics
            mae = mean_absolute_error(comparison_df["value"], comparison_df["forecasted_value"])
            rmse = np.sqrt(mean_squared_error(comparison_df["value"], comparison_df["forecasted_value"]))
            
            # Calculate MAPE
            mape = np.mean(np.abs((comparison_df["value"] - comparison_df["forecasted_value"]) / comparison_df["value"])) * 100
            
            # Calculate percentage of actual values within prediction intervals
            within_interval = ((comparison_df["value"] >= comparison_df["lower_bound"]) & 
                              (comparison_df["value"] <= comparison_df["upper_bound"]))
            interval_coverage = within_interval.mean() * 100
            
            return {
                "success": True,
                "kpi_name": kpi_name,
                "forecast_date": forecast_date,
                "comparison_period": {
                    "start_date": start_date,
                    "end_date": end_date
                },
                "metrics": {
                    "mae": mae,
                    "rmse": rmse,
                    "mape": mape,
                    "interval_coverage": interval_coverage
                },
                "data_points": len(comparison_df),
                "comparison_data": comparison_df
            }
        except Exception as e:
            frappe.log_error(
                f"Error comparing forecast with actual for KPI {kpi_name}: {str(e)}\n{frappe.get_traceback()}",
                "Forecast Comparison Error"
            )
            return {
                "success": False,
                "error": str(e),
                "kpi_name": kpi_name
            }


def generate_weekly_forecasts():
    """
    Scheduled task to generate weekly forecasts for all companies.
    
    This function is intended to be run as a scheduled task on weekends
    to generate forecasts for all forecastable KPIs and all companies.
    
    Returns:
        dict: Summary of forecasting results
    """
    try:
        # Get all active companies
        companies = frappe.get_all("Company", filters={"is_active": 1})
        
        results = {
            "total_companies": len(companies),
            "successful_companies": 0,
            "failed_companies": 0,
            "total_kpis": 0,
            "successful_kpis": 0,
            "failed_kpis": 0
        }
        
        # Process each company
        for company_doc in companies:
            company = company_doc.name
            try:
                # Create forecasting engine for this company
                engine = ForecastingEngine(company)
                
                # Forecast all KPIs
                kpi_results = engine.forecast_all_kpis()
                
                # Count successes and failures
                for kpi_name, result in kpi_results.items():
                    results["total_kpis"] += 1
                    if result["success"]:
                        results["successful_kpis"] += 1
                    else:
                        results["failed_kpis"] += 1
                
                results["successful_companies"] += 1
            except Exception as e:
                results["failed_companies"] += 1
                frappe.log_error(
                    f"Error processing company {company} for weekly forecasting: {str(e)}\n{frappe.get_traceback()}",
                    "Weekly Forecasting Error"
                )
        
        # Log summary
        frappe.log_error(
            f"Weekly forecasting completed: {json.dumps(results, indent=2)}",
            "Weekly Forecasting Summary"
        )
        
        return results
    except Exception as e:
        frappe.log_error(
            f"Error in weekly forecasting: {str(e)}\n{frappe.get_traceback()}",
            "Weekly Forecasting Error"
        )
        return {
            "error": str(e),
            "success": False
        }


# Command-line interface for testing
if __name__ == "__main__":
    import argparse
    
    parser = argparse.ArgumentParser(description="KPI Forecasting Tool")
    parser.add_argument("--company", help="Company to generate forecasts for")
    parser.add_argument("--kpi", help="KPI to forecast")
    parser.add_argument("--historical-days", type=int, default=365, help="Number of historical days to use")
    parser.add_argument("--forecast-periods", type=int, nargs="+", help="Periods to forecast")
    parser.add_argument("--weekly", action="store_true", help="Run weekly forecasting")
    
    args = parser.parse_args()
    
    if args.weekly:
        print("Running weekly forecasting...")
        results = generate_weekly_forecasts()
        print(json.dumps(results, indent=2))
    elif args.kpi:
        engine = ForecastingEngine(args.company)
        print(f"Forecasting KPI {args.kpi}...")
        results = engine.forecast_kpi(
            args.kpi,
            historical_days=args.historical_days,
            forecast_periods=args.forecast_periods
        )
        print(json.dumps(results, indent=2))
    else:
        parser.print_help()
